---
title: Paramètres du projet (conversion) (OracleToSQL) | Microsoft Docs
description: Découvrez comment utiliser la page conversion de la boîte de dialogue Paramètres du projet pour personnaliser la façon dont SSMA convertit la syntaxe Oracle en SQL Server syntaxe.
author: nahk-ivanov
ms.prod: sql
ms.custom: ''
ms.date: 12/17/2020
ms.reviewer: ''
ms.technology: ssma
ms.topic: conceptual
ms.assetid: a98a5e07-eb5e-47b9-a6f2-e2cb3a18309c
ms.author: alexiva
ms.openlocfilehash: 5c99ab8dec72a621ddb3f312e581907b0e4ba6d4
ms.sourcegitcommit: a16b98d3bf3eeb58f5d2aeece2464f8a96e2b4a8
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/18/2020
ms.locfileid: "97665858"
---
# <a name="project-settings-conversion-oracletosql"></a>Paramètres du projet (Conversion) (OracleToSQL)

La page **conversion** de la boîte de dialogue **paramètres du projet** contient des paramètres qui personnalisent la manière dont SSMA convertit la syntaxe Oracle en [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] syntaxe.

Le volet **conversion** est disponible dans les boîtes de dialogue **paramètres du projet** et paramètres du **projet par défaut** :

- Pour spécifier les paramètres de tous les projets SSMA, dans le menu **Outils** , cliquez sur **paramètres du projet par défaut**, sélectionnez le type de projet de migration pour lequel les paramètres doivent être affichés ou modifiés dans la liste déroulante de la **version cible** de la migration, puis cliquez sur **général** en bas du volet gauche, puis sur **conversion**.

- Pour spécifier les paramètres du projet actif, dans le menu **Outils** , cliquez sur **paramètres du projet**, puis sur **général** en bas du volet gauche, et enfin sur **conversion**.

## <a name="built-in-functions-and-supplied-packages"></a>Fonctions intégrées et packages fournis

|Terme|Définition|
|-|-|
|**Convertit la fonction COUNT en COUNT_BIG**|Si vos `COUNT` fonctions sont susceptibles de retourner des valeurs supérieures à 2 147 483 647, ce qui correspond à 2<sup>31</sup>-1, vous devez convertir les fonctions en `COUNT_BIG` .<br /><br />Si vous sélectionnez **Oui**, SSMA convertira toutes les utilisations de `COUNT` en `COUNT_BIG` .<br /><br />Si vous sélectionnez **non**, les fonctions sont conservées comme `COUNT` . [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] renverra une erreur si la fonction retourne une valeur supérieure à 2<sup>31</sup>-1.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/mode complet :** Oui<br />**Mode optimiste :** º|
|**Convertir les appels de fonction SUBSTR en appels de fonction de sous-chaîne**|SSMA peut convertir `SUBSTR` les appels de fonction Oracle en [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `substring` appels de fonction, en fonction du nombre de paramètres. Si SSMA ne peut pas convertir un `SUBSTR` appel de fonction ou si le nombre de paramètres n’est pas pris en charge, SSMA convertit l' `SUBSTR` appel de fonction en un appel de fonction SSMA personnalisé.<br /><br />Si vous sélectionnez **Oui**, SSMA convertira les `SUBSTR` appels de fonction qui utilisent trois paramètres dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `substring` . `SUBSTR`D’autres fonctions seront converties pour appeler la fonction SSMA personnalisée.<br /><br />Si vous sélectionnez **non**, SSMA convertit l' `SUBSTR` appel de fonction en un appel de fonction SSMA personnalisé.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** Oui<br />**Mode complet :** º|
|**Convertit les appels de fonction TO_CHAR (date, format)**|SSMA peut convertir Oracle `TO_CHAR(date, format)` en procédures à partir du `ssma_oracle` schéma.<br /><br />Si vous sélectionnez **à l’aide de TO_CHAR_DATE fonction**, SSMA convertit le `TO_CHAR(date, format)` en `TO_CHAR_DATE` fonction à l’aide de la langue anglaise pour la conversion.<br /><br />Si vous sélectionnez **à l’aide de TO_CHAR_DATE_LS fonction (soins nls)**, SSMA convertit le `TO_CHAR(date, format)` en `TO_CHAR_DATE_LS` fonction à l’aide de la langue de session pour la conversion<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** Utilisation de TO_CHAR_DATE fonction<br />**Mode complet :** Utilisation de TO_CHAR_DATE_LS fonction (soins NLS)|
|**Génère une erreur pour DBMS_SQL. ANALYS**|Si vous sélectionnez **erreur**, SSMA génère une erreur lors de la conversion `DBMS_SQL.PARSE` .<br /><br />Si vous sélectionnez **Avertissement**, SSMA génère un avertissement lors de la conversion `DBMS_SQL.PARSE` .<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br />**Mode par défaut/optimiste/mode complet :** Erreurs|
|**Utiliser ISNULL dans les appels de fonction CONCAt**|`ISNULL` l’instruction est utilisée dans les `CONCAT` appels de fonction pour émuler le comportement d’Oracle. Les options suivantes sont disponibles pour ce paramètre :<br /><br />YES<br /><br />Non<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** º<br />**Mode complet :** Oui|
|**Utilisation de ISNULL dans les appels de fonction Replace**|`ISNULL` l’instruction est utilisée dans les `REPLACE` appels de fonction pour émuler le comportement d’Oracle. Les options suivantes sont disponibles pour ce paramètre :<br /><br />YES<br /><br />Non<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** º<br />**Mode complet :** Oui|
|**Utiliser la fonction native Convert lorsque cela est possible**|Si vous sélectionnez **Oui**, SSMA convertit la valeur `TO_CHAR(date, format)` en fonction Convert Native lorsque cela est possible.<br /><br />Si vous sélectionnez **non**, SSMA convertit `TO_CHAR(date, format)` en `TO_CHAR_DATE` ou `TO_CHAR_DATE_LS` (il est défini par les options **Convert to_char (date, format)** ).<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** Oui<br />**Mode complet :** º|

## <a name="conversion-messages"></a>Messages de conversion

|Terme|Définition|
|-|-|
|**Générer des messages sur les problèmes**|Spécifie si SSMA génère des messages d’information au cours de la conversion, les affiche dans le volet de sortie et les ajoute au code converti.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** º<br />**Mode complet :** º|

## <a name="miscellaneous-options"></a>Options diverses

|Terme|Définition|
|-|-|
|**Convertir des expressions ROWNUM en entiers**|Lorsque SSMA convertit des `ROWNUM` expressions, il convertit l’expression en une `TOP` clause, suivie de l’expression. L’exemple suivant illustre `ROWNUM` une instruction Oracle `DELETE` :<br /><br />`DELETE FROM Table1`<br />`WHERE ROWNUM < expression and Field1 >= 2`<br /><br />L’exemple suivant illustre le résultat obtenu [!INCLUDE[tsql](../../includes/tsql-md.md)] :<br /><br />`DELETE TOP (expression-1)`<br />`FROM Table1`<br />`WHERE Field1>=2`<br /><br />Le `TOP` requiert que l' `TOP` expression des clauses corresponde à un entier. Si l’entier est négatif, l’instruction génère une erreur.<br /><br />Si vous sélectionnez **Oui**, SSMA effectue un cast de l’expression en tant qu’entier.<br /><br />Si vous sélectionnez **non**, SSMA marque toutes les expressions non entières comme une erreur dans le code converti.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/mode complet :** º<br />**Mode optimiste :** Oui|  
|**Mappage de schéma par défaut**|Ce paramètre spécifie la manière dont les schémas Oracle sont mappés à des schémas de SQL Server. Deux options sont disponibles dans ce paramètre :<br /><br />**Schéma dans la base de données :** Dans ce mode, le schéma Oracle `sch1` est mappé par défaut à `dbo` SQL Server schéma dans SQL Server base de données `sch1` .<br /><br />**Schéma vers schéma :** Dans ce mode, le schéma Oracle `sch1` est mappé par défaut à `sch1` SQL Server schéma dans la base de données SQL Server par défaut fournie dans la boîte de dialogue de connexion.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Schéma à base de données|
|**Émuler le comportement null d’Oracle dans les clauses ORDER BY**|`NULL` les valeurs sont classées différemment dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] et Oracle :<br /><br />Dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , `NULL` les valeurs sont les valeurs les plus basses dans une liste ordonnée. Dans une liste croissante, les `NULL` valeurs s’affichent en premier.<br /><br />Dans Oracle, `NULL` les valeurs sont les valeurs les plus élevées dans une liste ordonnée. Par défaut, `NULL` les valeurs apparaissent en dernier dans une liste d’ordre croissant.<br /><br />Oracle possède `NULLS FIRST` des `NULLS LAST` clauses et, qui vous permettent de modifier la façon dont Oracle Orders `NULL` s.<br /><br />SSMA peut émuler le `ORDER BY` comportement d’Oracle en vérifiant les `NULL` valeurs. Il commence par Trier par `NULL` valeurs dans l’ordre spécifié, puis par d’autres valeurs.<br /><br />Si vous sélectionnez **Oui**, SSMA convertit l’instruction Oracle d’une manière qui émule le comportement d’Oracle `ORDER BY` .<br /><br />Si vous sélectionnez **non**, SSMA ignore les règles Oracle et génère un message d’erreur quand il rencontre les `NULLS FIRST` `NULLS LAST` clauses et.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** º<br />**Mode complet :** Oui|
|**Émuler les exceptions de nombre de lignes dans SELECT**|Si une `SELECT` instruction avec une clause INTO ne retourne pas de lignes, Oracle lève une `NO_DATA_FOUND` exception. Si l’instruction retourne deux lignes ou plus, l' `TOO_MANY_ROWS` exception est levée. L’instruction convertie dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ne lève pas d’exception si le nombre de lignes est différent d’un.<br /><br />Si vous sélectionnez **Oui**, SSMA ajoute un appel à `db_error_exact_one_row_check` une procédure spéciale après chaque `SELECT` instruction. Cette procédure émule les `NO_DATA_FOUND` `TOO_MANY_ROWS` exceptions et. Il s’agit de la valeur par défaut, qui permet de reproduire le comportement Oracle le plus près possible. Vous devez toujours choisir **Oui** si le code source possède des gestionnaires d’exceptions qui traitent ces erreurs. Notez que si l' `SELECT` instruction se trouve à l’intérieur d’une fonction définie par l’utilisateur, ce module est converti en procédure stockée, car l’exécution de procédures stockées et le déclenchement d’exceptions ne sont pas compatibles avec le contexte de la [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] fonction.<br /><br />Si vous sélectionnez **non**, aucune exception n’est générée. Cela peut être utile lorsque SSMA convertit une fonction définie par l’utilisateur et que vous souhaitez qu’elle reste une fonction dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|
|**Activer Fix Advisor**|Lorsqu’il est activé, SSMA tente d’apprendre les modifications que vous apportez dans le code T-SQL cible et suggère des corrections de code potentielles dans un autre emplacement, où un modèle similaire peut être appliqué.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|
|**Générer des alias de colonnes d’expressions constantes**|S' `SELECT` il manque un alias dans la liste, SSMA peut générer un alias constant (comme `expr1` , `expr2` , etc.) ou utiliser l’expression elle-même comme alias. Étant donné que les expressions peuvent devenir assez longues et que la longueur du nom de colonne est limitée, il est plus sûr d’utiliser un nom de base constant pour ces alias. Même s’il s’agit d’une option plus sûre, il est parfois impossible, car il peut y avoir des dépendances externes sur le jeu de données résultant. Dans ce cas, vous pouvez nommer les colonnes en fonction de leurs expressions de valeur, de la même façon que le comportement d’Oracle.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** Oui<br />**Mode complet :** º|
|**Omettre les propriétés étendues**|Lorsqu’il est activé, SSMA n’ajoute pas de propriétés étendues aux objets qu’il crée dans la base de données cible.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** º|
|**Traduire les codes d’erreur**|Quand cette option est activée, le numéro d’erreur du côté SQL Server cible est traduit en code d’erreur Oracle si le mappage est trouvé.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/mode complet :** Oui<br />**Mode optimiste :** º|
|**Utiliser la spécification de type complet pour les références de type**|Lorsqu’il est activé, SSMA respecte la spécification de type complet (y compris la mise à l’échelle et la précision) pour les paramètres de routine et les valeurs de retour. Oracle n’autorise pas les arguments de type de données pour les paramètres de routine, mais dans certains cas, ils peuvent être implicitement dérivés, par exemple lorsque les `%TYPE` `%ROWTYPE` attributs et sont utilisés. Dans ce cas, SSMA peut utiliser la spécification de type complet (y compris la précision et l’échelle) lors de la conversion en SQL Server.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** Oui<br />**Mode complet :** º|
|**Utilisation de ISNULL dans une concaténation de chaînes**|Oracle et [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] retournent des résultats différents lorsque les concaténations de chaînes incluent des `NULL` valeurs. Oracle traite la `NULL` valeur comme un jeu de caractères vide. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] retourne `NULL`.<br /><br />Si vous sélectionnez **Oui**, SSMA remplace le caractère de concaténation Oracle (&#124;&#124;) par le [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] caractère de concaténation (+). SSMA vérifie également les expressions des deux côtés de la concaténation pour les `NULL` valeurs.<br /><br />Si vous sélectionnez **non**, SSMA remplace les caractères de concaténation, mais ne vérifie pas les `NULL` valeurs.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|

## <a name="objects-conversion"></a>Conversion d’objets

|Terme|Définition|
|-|-|
|**Convertir les clés étrangères avec l’action référentielle SET NULL sur la colonne qui n’est pas NULL**|Oracle permet de créer des contraintes de clé étrangère, où il n’est pas possible d' `SET NULL` effectuer une action, car les valeurs NULL ne sont pas autorisées dans la colonne référencée. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] n’autorise pas cette configuration de clé étrangère.<br /><br />Si vous sélectionnez **Oui**, SSMA générera des actions d’intégrité référentielle comme dans Oracle, mais vous devrez apporter des modifications manuelles avant de charger la contrainte sur [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] . Par exemple, vous pouvez choisir à la `NO ACTION` place de `SET NULL` .<br /><br />Si vous sélectionnez **non**, la contrainte est marquée comme une erreur.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** º|
|**Convertir les sous-types**|SSMA peut convertir les sous-types PL/SQL de deux manières :<br /><br />Si vous sélectionnez **Oui**, SSMA crée [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] un type défini par l’utilisateur à partir d’un sous-type et l’utilise pour chaque variable de ce sous-type.<br /><br />Si vous sélectionnez **non**, SSMA remplace toutes les déclarations sources du sous-type par le type sous-jacent et convertit le résultat comme d’habitude. Dans ce cas, aucun autre type n’est créé dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** º|
|**Convertir les synonymes**|Les synonymes des objets Oracle suivants peuvent être migrés vers [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] :<br /><br />Tables et tables d’objets<br /><br />Vues et vues d’objets<br /><br />Procédures stockées et fonctions<br /><br />Vues matérialisées<br /><br />**Synonymes pour les éléments suivants** Les objets Oracle peuvent être remplacés par des références directes aux objets :<br /><br />Séquences<br /><br />.<br /><br />Objets de schéma de classe Java<br /><br />Types d'objets définis par l'utilisateur<br /><br />D’autres synonymes ne peuvent pas être migrés. SSMA génère des messages d’erreur pour le synonyme et toutes les références qui utilisent le synonyme.<br /><br />Si vous sélectionnez **Oui**, SSMA créera [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] des synonymes et des références d’objets directs conformément aux listes précédentes.<br /><br />Si vous sélectionnez **non**, SSMA crée des références d’objet directes pour tous les synonymes répertoriés ici.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|
|**Conversion de modules locaux**|Définit le type de sous-programme Oracle imbriqué (déclaré dans une procédure stockée autonome ou une fonction).<br /><br />Si vous sélectionnez **inline**, les appels de sous-programme imbriqués seront remplacés par son corps.<br /><br />Si vous sélectionnez des **procédures stockées**, le sous-programme imbriqué sera converti en SQL Server procédure stockée, et ses appels seront remplacés lors de cet appel de procédure.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Inline|

## <a name="records-conversion"></a>Conversion des enregistrements

|Terme|Définition|
|-|-|
|**Convertir l’enregistrement en une liste de variables distinctes**|SSMA peut convertir les enregistrements Oracle en variables distinctes et en variables XML avec une structure spécifique.<br /><br />Si vous sélectionnez **Oui**, SSMA convertit l’enregistrement en une liste de variables distinctes, si possible.<br /><br />Si vous sélectionnez **non**, SSMA convertit l’enregistrement en variables XML avec une structure spécifique.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|
|**Utilisez SELECT... FOR XML lors de la conversion de SELECT... INTO pour la variable d’enregistrement**|Spécifie s’il faut générer un jeu de résultats XML lorsque vous sélectionnez dans une variable d’enregistrement.<br /><br />Si vous sélectionnez **Oui**, l’instruction Select retourne Xml.<br /><br />Si vous sélectionnez **non**, l’instruction Select retourne un jeu de résultats.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** º|

## <a name="returning-clause-conversion"></a>Returning, conversion de clause

|Terme|Définition|
|-|-|
|**Conversion de la clause Returning dans l’instruction DELETE en sortie**|Oracle fournit une `RETURNING` clause pour obtenir immédiatement les valeurs supprimées. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] fournit cette fonctionnalité avec la `OUTPUT` clause.<br /><br />Si vous sélectionnez **Oui**, SSMA convertira les `RETURNING` clauses dans les `DELETE` instructions en `OUTPUT` clauses. Étant donné que les déclencheurs sur une table peuvent modifier des valeurs, la valeur retournée peut être différente dans la mesure [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] où elle se trouvait dans Oracle.<br /><br />Si vous sélectionnez **non**, SSMA génère une `SELECT` instruction avant les `DELETE` instructions pour récupérer les valeurs retournées.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|
|**Conversion de la clause Returning dans l’instruction INSERT en sortie**|Oracle fournit une `RETURNING` clause pour obtenir immédiatement des valeurs insérées. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] fournit cette fonctionnalité avec la `OUTPUT` clause.<br /><br />Si vous sélectionnez **Oui**, SSMA convertit une `RETURNING` clause dans une `INSERT` instruction en `OUTPUT` . Étant donné que les déclencheurs sur une table peuvent modifier des valeurs, la valeur retournée peut être différente dans la mesure [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] où elle se trouvait dans Oracle.<br /><br />Si vous sélectionnez **non**, SSMA émule la fonctionnalité Oracle en insérant, puis en sélectionnant des valeurs dans une table de référence.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|
|**Conversion de la clause Returning dans l’instruction UPDATE en sortie**|Oracle fournit une `RETURNING` clause pour obtenir immédiatement les valeurs mises à jour. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] fournit cette fonctionnalité avec la `OUTPUT` clause.<br /><br />Si vous sélectionnez **Oui**, SSMA convertira les `RETURNING` clauses dans les `UPDATE` instructions en `OUTPUT` clauses. Étant donné que les déclencheurs sur une table peuvent modifier des valeurs, la valeur retournée peut être différente dans la mesure [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] où elle se trouvait dans Oracle.<br /><br />Si vous sélectionnez **non**, SSMA génère des instructions SELECT après les `UPDATE` instructions pour récupérer les valeurs de retour.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|

## <a name="rowid-generation"></a>Génération de ROWID

|Terme|Définition|
|-|-|
|**Générer la colonne ROWID**|Lorsque SSMA crée des tables dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , il peut créer une colonne ROWID. Lorsque les données sont migrées, chaque ligne obtient une nouvelle `UNIQUEIDENTIFIER` valeur générée par la `newid()` fonction.<br /><br />Si vous sélectionnez **Oui**, la `ROWID` colonne est créée sur toutes les tables et [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] génère des GUID au fur et à mesure que vous insérez des valeurs. Choisissez toujours **Oui** si vous envisagez d’utiliser le testeur SSMA.<br /><br />Si vous sélectionnez **non**, les colonnes ROWID ne sont pas ajoutées aux tables.<br /><br />**Ajoutez la colonne ROWID pour les tables avec déclencheurs** Add `ROWID` pour les tables contenant des déclencheurs.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** Ajouter une colonne ROWID pour les tables avec des déclencheurs<br /><br />**Mode complet :** Oui|
|**Générer un index unique sur la colonne ROWID**|Spécifie si SSMA génère ou non une colonne d’index unique sur la `ROWID` colonne générée. Si l’option est définie sur « Oui », l’index unique est généré et, s’il est défini sur « non », l’index unique n’est pas généré sur la `ROWID` colonne.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|

## <a name="sequence-and-identity-conversion"></a>Conversion des séquences et des identités

|Terme|Définition|
|-|-|
|**Convertir l’identité en**|Oracle fournit plusieurs options de configuration pour les colonnes d’identité. Certaines de ces options ne sont pas prises en charge par la fonctionnalité d’identité dans SQL Server.<br /><br />Une méthode de conservation de ces options consiste à convertir l’identité en une séquence.<br /><br />Si vous sélectionnez **séquence**, les colonnes d’identité Oracle ne seront plus converties en colonnes d’identité SQL. Au lieu de cela, une séquence est créée et utilisée pour générer les valeurs par défaut de la colonne.<br /><br />Si vous sélectionnez **identité**, les colonnes d’identité Oracle seront converties en colonnes d’identité SQL. Les options non prises en charge ne seront pas converties. <br /><br />Si vous sélectionnez **meilleur ajustement**, SSMA déterminera la méthode de conversion la mieux adaptée (identité ou séquence) en fonction de la configuration de la colonne d’identité Oracle.|
|**Convertir le générateur de séquence**|Dans Oracle, vous pouvez utiliser une séquence pour générer des identificateurs uniques.<br /><br />SSMA peut convertir les séquences vers les éléments suivants.<br /><br />Utilisation de SQL Server Générateur de séquence.<br /><br />À l’aide du générateur de séquence SSMA.<br /><br />Utilisation de l’identité de colonne.<br /><br />L’option par défaut consiste à utiliser SQL Server Générateur de séquence. Toutefois, SQL Server ne prend pas en charge l’obtention de la valeur de séquence actuelle (telle que celle de la méthode de séquence Oracle `CURRVAL` ). Consultez le site du blog de l’équipe SSMA pour obtenir de l’aide sur la migration de la méthode de séquence Oracle `CURRVAL` .<br /><br />SSMA fournit également une option permettant de convertir une séquence Oracle en émulateur de séquence SSMA. Il s’agit de l’option par défaut lors de la conversion en SQL Server avant 2012<br /><br />Enfin, vous pouvez également convertir une séquence assignée à une colonne de table en SQL Server valeurs d’identité. Vous devez spécifier le mappage entre les séquences et une colonne d’identité sous l’onglet **table** Oracle.|
|**Convertir les CURRVAL en dehors des déclencheurs**|Visible uniquement lorsque le **Générateur de séquence Convert** a la valeur à **l’aide de l’identité de colonne**. Étant donné que les séquences Oracle sont des objets distincts des tables, de nombreuses tables qui utilisent des séquences utilisent un déclencheur pour générer et insérer une nouvelle valeur de séquence. SSMA commente ces instructions ou les marque comme des erreurs lorsque les commentaires génèrent des erreurs.<br /><br />Si vous sélectionnez **Oui**, SSMA marque toutes les références aux déclencheurs externes sur la séquence convertie `CURRVAL` avec un avertissement.<br /><br />Si vous sélectionnez **non**, SSMA marque toutes les références aux déclencheurs externes sur la séquence convertie `CURRVAL` avec une erreur.|

## <a name="statements-conversion"></a>Conversion des instructions

|Terme|Définition|
|-|-|
|**Conversion de l’instruction MERGE**|Si vous sélectionnez **à l’aide de l’instruction INSERT, Update, Delete**, SSMA convertit l' `MERGE` instruction en `INSERT` `UPDATE` instructions,, `DELETE` .<br /><br />Si vous sélectionnez **à l’aide de l’instruction MERGE**, SSMA convertit l' `MERGE` instruction en `MERGE` instruction dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] .<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Utilisation de l’instruction MERGE|
|**Convertir les appels aux sous-programmes qui utilisent des arguments par défaut**|[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] les fonctions ne prennent pas en charge l’omission de paramètres dans l’appel de fonction. En outre, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] les fonctions et les procédures ne prennent pas en charge les expressions comme valeurs de paramètre par défaut.<br /><br />Si vous sélectionnez **Oui** et qu’un appel de fonction omet des paramètres, SSMA insère le mot clé **default** dans la fonction et appelle à la position correcte. Ensuite, l’appel est marqué avec un avertissement.<br /><br />Si vous sélectionnez **non**, SSMA marquera les appels de fonction comme des erreurs.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|
|**Convertir l’instruction FORALL en instruction WHILe**|Définit la façon dont SSMA traitera les `FORALL` boucles sur les éléments de collection PL/SQL.<br /><br />Si vous sélectionnez **Oui**, SSMA crée une `WHILE` boucle où les éléments de la collection sont récupérés un par un.<br /><br />Si vous sélectionnez **non**, SSMA génère un ensemble de lignes à partir de la collection à l’aide de la `nodes()` méthode et l’utilise comme table unique. Cette solution est plus efficace, mais rend le code de sortie moins lisible.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** º<br />**Mode complet :** Oui|
|**Convertir les appels de fonction en appels de procédure**|Certaines fonctions Oracle sont définies en tant que transactions autonomes ou contiennent des instructions qui ne sont pas valides dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] . Dans ce cas, SSMA crée une procédure et une fonction qui est un wrapper pour la procédure. La fonction convertie appelle la procédure d’implémentation.<br /><br />SSMA peut convertir les appels à la fonction wrapper en appels à la procédure. Cela crée un code plus lisible et peut améliorer les performances. Toutefois, le contexte ne l’autorise pas toujours ; par exemple, vous ne pouvez pas remplacer un appel de fonction dans `SELECT` List par un appel de procédure. SSMA offre plusieurs options pour couvrir les cas courants :<br /><br />Si vous sélectionnez **toujours**, SSMA tente de convertir les appels de fonction wrapper en appels de procédure. Si le contexte actuel n’autorise pas cette conversion, un message d’erreur est généré. De cette façon, aucun appel de fonction n’est laissé dans le code généré.<br /><br />Si vous sélectionnez dans la **mesure du possible**, SSMA effectue un déplacement vers les appels de procédure uniquement si la fonction a des paramètres de sortie. Lorsque le déplacement n’est pas possible, l’attribut de sortie du paramètre est supprimé. Dans tous les autres cas, SSMA quitte les appels de fonction.<br /><br />Si vous sélectionnez **Never**, SSMA laisse tous les appels de fonction en tant qu’appels de fonction. Ce choix peut parfois être inacceptable pour des raisons de performances.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Lorsque cela est possible|
|**Convertir les instructions de TABLE LOCK**|SSMA peut convertir de nombreuses `LOCK TABLE` instructions en indicateurs de table. SSMA ne peut pas convertir les `LOCK TABLE` instructions qui contiennent des `PARTITION` `SUBPARTITION` `@dblink` clauses,, et `NOWAIT` , et marque ces instructions avec des messages d’erreur de conversion.<br /><br />Si vous sélectionnez **Oui**, SSMA convertira les instructions prises en charge `LOCK TABLE` en indicateurs de table.<br /><br />Si vous sélectionnez **non**, SSMA marque toutes les `LOCK TABLE` instructions avec des messages d’erreur de conversion.<br /><br />Le tableau suivant montre comment SSMA convertit les modes de verrouillage Oracle :<br /><br />**Mode de verrouillage Oracle**<br /><br />`ROW SHARE`<br />`ROW EXCLUSIVE`<br />`SHARE UPDATE = ROW SHARE`<br />`SHARE`<br />`SHARE`<br />`EXCLUSIVE`<br /><br />**Indicateur de table SQL Server**<br /><br />`ROWLOCK, HOLDLOCK`<br />`ROWLOCK, XLOCK, HOLDLOCK`<br />`ROWLOCK, HOLDLOCK`<br />`TABLOCK, HOLDLOCK`<br />`TABLOCK, XLOCK, HOLDLOCK`<br />`TABLOCKX, HOLDLOCK`<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|
|**Convertir les instructions OPEN-FOR pour les paramètres de sortie de REF CURSOR**|Dans Oracle, l' `OPEN .. FOR` instruction peut être utilisée pour retourner un jeu de résultats au `OUT` paramètre d’un sous-programme de type `REF CURSOR` . Dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , les procédures stockées retournent directement les résultats des `SELECT` instructions.<br /><br />SSMA peut convertir de nombreuses `OPEN .. FOR` instructions en `SELECT` instructions.<br /><br />Si vous sélectionnez **Oui**, SSMA convertit l' `OPEN .. FOR` instruction en une `SELECT` instruction, qui retourne le jeu de résultats au client.<br /><br />Si vous sélectionnez **non**, SSMA génère un message d’erreur dans le code converti et dans le volet de sortie.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|
|**Convertir les instructions de traitement des transactions**|SSMA peut convertir les instructions de traitement des transactions Oracle :<br /><br />Si vous sélectionnez **Oui**, SSMA convertit les instructions de traitement des transactions Oracle en [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] instructions.<br /><br />Si vous sélectionnez **non**, SSMA marque les instructions de traitement de transaction comme des erreurs de conversion.<br /><br />**Remarque :** Oracle ouvre les transactions de manière implicite. Pour émuler ce comportement sur [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , vous devez ajouter `BEGIN TRANSACTION` manuellement des instructions là où vous souhaitez que vos transactions démarrent. Vous pouvez également exécuter la `SET IMPLICIT_TRANSACTIONS ON` commande au début de votre session. SSMA `SET IMPLICIT_TRANSACTIONS ON` s’ajoute automatiquement lors de la conversion de sous-routines avec des transactions autonomes.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|

## <a name="see-also"></a>Voir aussi

[Guide de référence de l’interface utilisateur (OracleToSQL)](../../ssma/oracle/user-interface-reference-oracletosql.md)
