---
title: Paramètres du projet (conversion) (OracleToSQL) | Microsoft Docs
description: Découvrez comment utiliser la page conversion de la boîte de dialogue Paramètres du projet pour personnaliser la façon dont SSMA convertit la syntaxe Oracle en SQL Server syntaxe.
ms.prod: sql
ms.custom: ''
ms.date: 01/19/2017
ms.reviewer: ''
ms.technology: ssma
ms.topic: conceptual
ms.assetid: a98a5e07-eb5e-47b9-a6f2-e2cb3a18309c
author: Shamikg
ms.author: Shamikg
manager: shamikg
ms.openlocfilehash: a822aa1e9c30e245b61bd43c0af60b94fae33fe1
ms.sourcegitcommit: df1f0f2dfb9452f16471e740273cd1478ff3100c
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/29/2020
ms.locfileid: "87394910"
---
# <a name="project-settings-conversion-oracletosql"></a>Paramètres du projet (Conversion) (OracleToSQL)
La page conversion de la boîte de dialogue **paramètres du projet** contient des paramètres qui personnalisent la manière dont SSMA convertit la syntaxe Oracle en [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] syntaxe.  
  
Le volet conversion est disponible dans les boîtes de dialogue **paramètres du projet** et **paramètres du projet par défaut** :  
  
-   Pour spécifier les paramètres de tous les projets SSMA, dans le menu **Outils** , cliquez sur **paramètres du projet par défaut**, sélectionnez le type de projet de migration pour lequel les paramètres doivent être affichés ou modifiés dans la liste déroulante de la **version cible** de la migration, puis cliquez sur **général** en bas du volet gauche, puis sur **conversion**.  
  
-   Pour spécifier les paramètres du projet actif, dans le menu **Outils** , cliquez sur **paramètres du projet**, puis sur **général** en bas du volet gauche, et enfin sur **conversion**.  
  
## <a name="conversion-messages"></a>Messages de conversion  
  
|Terme|Définition|  
|-|-|  
|**Générer des messages sur les problèmes appliqués**|Spécifie si SSMA génère des messages d’information au cours de la conversion, les affiche dans le volet de sortie et les ajoute au code converti.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** º<br /><br />**Mode complet :** º|  
  
## <a name="miscellaneous-options"></a>Options diverses  
  
|Terme|Définition|  
|-|-|  
|**Convertir des expressions ROWNUM en entiers**|Lorsque SSMA convertit des expressions ROWNUM, il convertit l’expression en une clause TOP, suivie de l’expression. L’exemple suivant montre ROWNUM dans une instruction Oracle DELETE :<br /><br />`DELETE FROM Table1`<br /><br />`WHERE ROWNUM < expression and Field1 >= 2`<br /><br />L’exemple suivant illustre le résultat obtenu [!INCLUDE[tsql](../../includes/tsql-md.md)] :<br /><br />`DELETE TOP (expression-1)`<br /><br />`FROM Table1`<br /><br />`WHERE Field1>=2`<br /><br />Le TOP requiert que l’expression des clauses supérieures corresponde à un entier. Si l’entier est négatif, l’instruction génère une erreur.<br /><br />Si vous sélectionnez **Oui**, SSMA effectue un cast de l’expression en tant qu’entier.<br /><br />Si vous sélectionnez **non**, SSMA marque toutes les expressions non entières comme une erreur dans le code converti.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/mode complet :** º<br /><br />**Mode optimiste :** Oui|  
|**Mappage de schéma par défaut**|Ce paramètre spécifie la manière dont les schémas Oracle sont mappés à des schémas de SQL Server. Deux options sont disponibles dans ce paramètre :<br /><br />**Schéma dans la base de données :** Dans ce mode, le schéma Oracle « Sch1 » est mappé par défaut à « dbo » SQL Server schéma dans SQL Server base de données « Sch1 ».<br /><br />**Schéma vers schéma :** Dans ce mode, le schéma Oracle « Sch1 » est mappé par défaut à « Sch1 » SQL Server schéma dans la base de données SQL Server par défaut fournie dans la boîte de dialogue de connexion.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Schéma à base de données|  
|**Méthodes de conversion de l’instruction MERGE**|Si vous sélectionnez **à l’aide de l’instruction INSERT, Update et Delete**, SSMA convertit l’instruction de fusion en instructions INSERT, Update et DELETE.<br /><br />Si vous sélectionnez **à l’aide de l’instruction MERGE**, SSMA convertit l’instruction de fusion en instruction MERGE dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] .<br /><br />**Remarque :** Cette option de paramètre de projet est disponible uniquement dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 2008, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 2012, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 2014.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Utilisation de l’instruction MERGE|  
|**Convertir les appels aux sous-programmes qui utilisent des arguments par défaut**|[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]les fonctions ne prennent pas en charge l’omission de paramètres dans l’appel de fonction. En outre, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] les fonctions et les procédures ne prennent pas en charge les expressions comme valeurs de paramètre par défaut.<br /><br />Si vous sélectionnez **Oui** et qu’un appel de fonction omet des paramètres, SSMA insère le mot clé **default** dans la fonction et appelle à la position correcte. Ensuite, l’appel est marqué avec un avertissement.<br /><br />Si vous sélectionnez **non**, SSMA marquera les appels de fonction comme des erreurs.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|  
|**Convertit la fonction COUNT en COUNT_BIG**|Si vos fonctions COUNT sont susceptibles de retourner des valeurs supérieures à 2 147 483 647, ce qui correspond à 2<sup>31</sup>-1, vous devez convertir les fonctions en COUNT_BIG.<br /><br />Si vous sélectionnez **Oui**, SSMA convertit toutes les utilisations de COUNT en COUNT_BIG.<br /><br />Si vous sélectionnez **non**, les fonctions sont conservées en tant que nombre. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]renverra une erreur si la fonction retourne une valeur supérieure à 2<sup>31</sup>-1.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/mode complet :** Oui<br /><br />**Mode optimiste :** º|  
|**Convertir l’instruction FORALL en instruction WHILe**|Définit la façon dont SSMA traitera les boucles FORALL sur les éléments de collection PL/SQL.<br /><br />Si vous sélectionnez **Oui**, SSMA crée une boucle while dans laquelle les éléments de la collection sont récupérés un par un.<br /><br />Si vous sélectionnez **non**, SSMA génère un ensemble de lignes à partir de la collection à l’aide de la méthode nodes () et l’utilise comme table unique. Cette solution est plus efficace, mais rend le code de sortie moins lisible.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** º<br /><br />**Mode complet :** Oui|  
|**Convertir les clés étrangères avec l’action référentielle SET NULL sur la colonne qui n’est pas NULL**|Oracle permet de créer des contraintes de clé étrangère, où une action de définition de valeur NULL n’a pas pu être effectuée, car les valeurs NULL ne sont pas autorisées dans la colonne référencée. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]n’autorise pas cette configuration de clé étrangère.<br /><br />Si vous sélectionnez **Oui**, SSMA générera des actions d’intégrité référentielle comme dans Oracle, mais vous devrez apporter des modifications manuelles avant de charger la contrainte sur [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] . Par exemple, vous pouvez choisir aucune ACTION au lieu de définir la valeur NULL.<br /><br />Si vous sélectionnez **non**, la contrainte est marquée comme une erreur.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** º|  
|**Convertir les appels de fonction en appels de procédure**|Certaines fonctions Oracle sont définies en tant que transactions autonomes ou contiennent des instructions qui ne sont pas valides dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] . Dans ce cas, SSMA crée une procédure et une fonction qui est un wrapper pour la procédure. La fonction convertie appelle la procédure d’implémentation.<br /><br />SSMA peut convertir les appels à la fonction wrapper en appels à la procédure. Cela crée un code plus lisible et peut améliorer les performances. Toutefois, le contexte ne l’autorise pas toujours ; par exemple, vous ne pouvez pas remplacer un appel de fonction dans la liste de sélection par un appel de procédure. SSMA offre plusieurs options pour couvrir les cas courants :<br /><br />Si vous sélectionnez **toujours**, SSMA tente de convertir les appels de fonction wrapper en appels de procédure. Si le contexte actuel n’autorise pas cette conversion, un message d’erreur est généré. De cette façon, aucun appel de fonction n’est laissé dans le code généré.<br /><br />Si vous sélectionnez dans la **mesure du possible**, SSMA effectue un déplacement vers les appels de procédure uniquement si la fonction a des paramètres de sortie. Lorsque le déplacement n’est pas possible, l’attribut de sortie du paramètre est supprimé. Dans tous les autres cas, SSMA quitte les appels de fonction.<br /><br />Si vous sélectionnez **Never**, SSMA laisse tous les appels de fonction en tant qu’appels de fonction. Ce choix peut parfois être inacceptable pour des raisons de performances.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Lorsque cela est possible|  
|**Convertir les instructions de TABLE LOCK**|SSMA peut convertir de nombreuses instructions LOCK TABLE en indicateurs de table. SSMA ne peut pas convertir les instructions de TABLE de VERROUs qui contiennent des clauses de PARTITION, de sous-PARTITION, @dblink et NOWAIT et marque ces instructions avec des messages d’erreur de conversion.<br /><br />Si vous sélectionnez **Oui**, SSMA convertira les instructions Lock table prises en charge en indicateurs de table.<br /><br />Si vous sélectionnez **non**, SSMA marque toutes les instructions Lock table avec des messages d’erreur de conversion.<br /><br />Le tableau suivant montre comment SSMA convertit les modes de verrouillage Oracle :<br /><br />**Mode de verrouillage Oracle**<br /><br />PARTAGE DE LIGNES<br /><br />LIGNE EXCLUSIVE<br /><br />PARTAGE DE MISE À JOUR = PARTAGE DE LIGNES<br /><br />PARTAGER<br /><br />PARTAGER<br /><br />Or<br /><br />**Indicateur de table SQL Server**<br /><br />ROWLOCK, HOLDLOCK<br /><br />ROWLOCK, XLOCK, HOLDLOCK<br /><br />ROWLOCK, HOLDLOCK<br /><br />TABLOCK, HOLDLOCK<br /><br />TABLOCK, XLOCK, HOLDLOCK<br /><br />TABLOCKX, HOLDLOCK<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|  
|**Convertir les instructions OPEN-FOR pour les paramètres de sortie de REF CURSOR**|Dans Oracle, l’instruction OPEN-FOR peut être utilisée pour retourner un jeu de résultats au paramètre OUT d’un sous-programme de type REF CURSOR. Dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , les procédures stockées retournent directement les résultats des instructions SELECT.<br /><br />SSMA peut convertir de nombreuses instructions OPEN-FOR en instructions SELECT.<br /><br />Si vous sélectionnez **Oui**, SSMA convertit l’instruction Open-for en une instruction SELECT, qui retourne le jeu de résultats au client.<br /><br />Si vous sélectionnez **non**, SSMA génère un message d’erreur dans le code converti et dans le volet de sortie.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|  
|**Convertir l’enregistrement en une liste de variables distinctes**|SSMA peut convertir les enregistrements Oracle en variables distinctes et en variables XML avec une structure spécifique.<br /><br />Si vous sélectionnez **Oui**, SSMA convertit l’enregistrement en une liste de variables distinctes, si possible.<br /><br />Si vous sélectionnez **non**, SSMA convertit l’enregistrement en variables XML avec une structure spécifique.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|  
|**Convertir les appels de fonction SUBSTR en appels de fonction de sous-chaîne**|SSMA peut convertir les appels de fonction SUBSTR [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] d’Oracle en appels de fonction de **sous-chaîne** , selon le nombre de paramètres. Si SSMA ne peut pas convertir un appel de fonction SUBSTR ou si le nombre de paramètres n’est pas pris en charge, SSMA convertit l’appel de fonction SUBSTR en un appel de fonction SSMA personnalisé.<br /><br />Si vous sélectionnez **Oui**, SSMA convertit les appels de fonction substr qui utilisent trois paramètres en [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **sous-chaîne**. D’autres fonctions SUBSTR seront converties pour appeler la fonction SSMA personnalisée.<br /><br />Si vous sélectionnez **non**, SSMA convertit l’appel de fonction substr en appel de fonction SSMA personnalisé.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** Oui<br /><br />**Mode complet :** º|  
|**Convertir les sous-types**|SSMA peut convertir les sous-types PL/SQL de deux manières :<br /><br />Si vous sélectionnez **Oui**, SSMA crée [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] un type défini par l’utilisateur à partir d’un sous-type et l’utilise pour chaque variable de ce sous-type.<br /><br />Si vous sélectionnez **non**, SSMA remplace toutes les déclarations sources du sous-type par le type sous-jacent et convertit le résultat comme d’habitude. Dans ce cas, aucun autre type n’est créé dans[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** º|  
|**Convertir les synonymes**|Les synonymes des objets Oracle suivants peuvent être migrés vers [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] :<br /><br />Tables et tables d’objets<br /><br />Vues et vues d’objets<br /><br />Procédures stockées et fonctions<br /><br />Vues matérialisées<br /><br />**Synonymes pour les éléments suivants** Les objets Oracle peuvent être remplacés par des références directes aux objets :<br /><br />Séquences<br /><br />.<br /><br />Objets de schéma de classe Java<br /><br />Types d'objets définis par l'utilisateur<br /><br />D’autres synonymes ne peuvent pas être migrés. SSMA génère des messages d’erreur pour le synonyme et toutes les références qui utilisent le synonyme.<br /><br />Si vous sélectionnez **Oui**, SSMA créera [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] des synonymes et des références d’objets directs conformément aux listes précédentes.<br /><br />Si vous sélectionnez **non**, SSMA crée des références d’objet directes pour tous les synonymes répertoriés ici.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|  
|**Convertir TO_CHAR (date, format)**|SSMA peut convertir les TO_CHAR Oracle (date, format) en procédures à partir de la base de données sysdb.<br /><br />Si vous sélectionnez **à l’aide de TO_CHAR_DATE fonction**, SSMA convertit le to_char (date, format) en TO_CHAR_DATE fonction à l’aide de la langue anglaise pour la conversion.<br /><br />Si vous sélectionnez **à l’aide de TO_CHAR_DATE_LS fonction (nls Care)**, SSMA convertit le to_char (date, format) en TO_CHAR_DATE_LS fonction à l’aide de la langue de session pour la conversion<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** Utilisation de TO_CHAR_DATE fonction<br /><br />**Mode complet :** Utilisation de TO_CHAR_DATE_LS fonction (soins NLS)|  
|**Convertir les instructions de traitement des transactions**|SSMA peut convertir les instructions de traitement des transactions Oracle :<br /><br />Si vous sélectionnez **Oui**, SSMA convertit les instructions de traitement des transactions Oracle en [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] instructions.<br /><br />Si vous sélectionnez **non**, SSMA marque les instructions de traitement de transaction comme des erreurs de conversion.<br /><br />**Remarque :**  Oracle ouvre les transactions de manière implicite. Pour émuler ce comportement sur [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , vous devez ajouter BEGIN TRANSACTION instructions manuellement à l’emplacement où vous souhaitez que vos transactions démarrent. Vous pouvez également exécuter la commande SET IMPLICIT_TRANSACTIONS ON au début de votre session. SSMA ajoute des IMPLICIT_TRANSACTIONS définies automatiquement lors de la conversion de sous-routines avec des transactions autonomes.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|  
|**Émuler le comportement null d’Oracle dans les clauses ORDER BY**|Les valeurs NULL sont classées différemment dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] et Oracle :<br /><br />Dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , les valeurs NULL sont les valeurs les plus basses dans une liste ordonnée. Dans une liste croissante, les valeurs NULL s’affichent en premier.<br /><br />Dans Oracle, les valeurs NULL sont les valeurs les plus élevées dans une liste ordonnée. Par défaut, les valeurs NULL apparaissent en dernier dans une liste d’ordre croissant.<br /><br />Oracle a d’abord des valeurs NULL et des dernières clauses NULL, ce qui vous permet de modifier la façon dont Oracle trie les valeurs NULL.<br /><br />SSMA peut émuler le comportement d’Oracle ORDER BY en vérifiant les valeurs NULL. Ensuite, il trie d’abord les valeurs NULL dans l’ordre spécifié, puis les trie par d’autres valeurs.<br /><br />Si vous sélectionnez **Oui**, SSMA convertit l’instruction Oracle d’une manière qui émule le comportement d’Oracle order by.<br /><br />Si vous sélectionnez **non**, SSMA ignore les règles Oracle et génère un message d’erreur quand il rencontre les premières clauses null et les dernières valeurs NULL.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** º<br /><br />**Mode complet :** Oui|  
|**Émuler les exceptions de nombre de lignes dans SELECT**|Si une instruction SELECT avec une clause INTO ne retourne pas de lignes, Oracle déclenche une exception NO_DATA_FOUND. Si l’instruction retourne deux lignes ou plus, l’exception TOO_MANY_ROWS est levée. L’instruction convertie dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] ne lève pas d’exception si le nombre de lignes est différent d’un.<br /><br />Si vous sélectionnez **Oui**, SSMA ajoute l’appel à la procédure sysdb db_error_exact_one_row_check après chaque instruction SELECT. Cette procédure émule les exceptions NO_DATA_FOUND et TOO_MANY_ROWS. Il s’agit de la valeur par défaut, qui permet de reproduire le comportement Oracle le plus près possible. Vous devez toujours choisir **Oui** si le code source possède des gestionnaires d’exceptions qui traitent ces erreurs. Notez que si l’instruction SELECT apparaît à l’intérieur d’une fonction définie par l’utilisateur, ce module est converti en une procédure stockée, car l’exécution de procédures stockées et le déclenchement d’exceptions ne sont pas compatibles avec le contexte de la [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] fonction.<br /><br />Si vous sélectionnez **non**, aucune exception n’est générée. Cela peut être utile lorsque SSMA convertit une fonction définie par l’utilisateur et que vous souhaitez qu’elle reste une fonction dans[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|  
|**Génère une erreur pour DBMS_SQL. ANALYS**|Si vous sélectionnez **erreur**, SSMA génère une erreur lors de la DBMS_SQL de la conversion. Analys.<br /><br />Si vous sélectionnez **Avertissement**, SSMA génère un avertissement au DBMS_SQL de la conversion. Analys.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Erreurs|  
|**Générer la colonne ROWID**|Lorsque SSMA crée des tables dans [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , il peut créer une colonne ROWID. Lorsque les données sont migrées, chaque ligne obtient une nouvelle valeur UNIQUEIDENTIFIER générée par la fonction NEWID ().<br /><br />Si vous sélectionnez **Oui**, la colonne ROWID est créée sur toutes les tables et [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] génère des GUID au fur et à mesure que vous insérez des valeurs. Choisissez toujours **Oui** si vous envisagez d’utiliser le testeur SSMA.<br /><br />Si vous sélectionnez **non**, les colonnes ROWID ne sont pas ajoutées aux tables.<br /><br />**Ajouter la colonne ROWID pour les tables avec déclencheurs** ajoutez ROWID pour les tables contenant des déclencheurs.<br /><br />**Remarque :** Paramètre par défaut dans le cas de SQL Server 2005, SQL Server 2008 et SQL Server 2012 et 2014 est **Ajouter la colonne ROWID pour les tables avec des déclencheurs**.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** Ajouter une colonne ROWID pour les tables avec des déclencheurs<br /><br />**Mode complet :** Oui|  
|**Générer un index unique sur la colonne ROWID**|Spécifie si SSMA génère ou non une colonne d’index unique sur la colonne de ROWID générée. Si l’option est définie sur « Oui », l’index unique est généré et, s’il est défini sur « non », l’index unique n’est pas généré sur la colonne ROWID.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|  
|**Conversion de modules locaux**|Définit le type de sous-programme Oracle imbriqué (déclaré dans une procédure stockée autonome ou une fonction).<br /><br />Si vous sélectionnez **inline**, les appels de sous-programme imbriqués seront remplacés par son corps.<br /><br />Si vous sélectionnez des **procédures stockées**, le sous-programme imbriqué sera converti en SQL Server procédure stockée, et ses appels seront remplacés lors de cet appel de procédure.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Inline|  
|**Utilisation de ISNULL dans une concaténation de chaînes**|Oracle et [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] retournent des résultats différents lorsque les concaténations de chaînes incluent des valeurs NULL. Oracle traite la valeur NULL comme un jeu de caractères vide. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]retourne la valeur NULL.<br /><br />Si vous sélectionnez **Oui**, SSMA remplace le caractère de concaténation Oracle (&#124;&#124;) par le [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] caractère de concaténation (+). SSMA vérifie également les expressions des deux côtés de la concaténation pour les valeurs NULL.<br /><br />Si vous sélectionnez **non**, SSMA remplace les caractères de concaténation, mais ne vérifie pas la valeur null.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|  
|**Utilisation de ISNULL dans les appels de fonction Replace**|L’instruction ISNULL est utilisée dans les appels de fonction Replace pour émuler le comportement d’Oracle. Les options suivantes sont disponibles pour ce paramètre :<br /><br />YES<br /><br />Non<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** º<br /><br />**Mode complet :** Oui|  
|**Utiliser ISNULL dans les appels de fonction CONCAt**|L’instruction ISNULL est utilisée dans les appels de fonction CONCAt pour émuler le comportement d’Oracle. Les options suivantes sont disponibles pour ce paramètre :<br /><br />YES<br /><br />Non<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** º<br /><br />**Mode complet :** Oui|  
|**Utiliser la fonction native Convert lorsque cela est possible**|Si vous sélectionnez **Oui**, SSMA convertit le to_char (date, format) en fonction Convert Native lorsque cela est possible.<br /><br />Si vous sélectionnez **non**, SSMA convertit le to_char (date, format) en TO_CHAR_DATE ou TO_CHAR_DATE_LS (il est défini par les options « convertir les to_char (date, format) »).<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste :** Oui<br /><br />**Mode complet :** º|  
|**Utilisez SELECT... FOR XML lors de la conversion de SELECT... INTO pour la variable d’enregistrement**|Spécifie s’il faut générer un jeu de résultats XML lorsque vous sélectionnez dans une variable d’enregistrement.<br /><br />Si vous sélectionnez **Oui**, l’instruction Select retourne Xml.<br /><br />Si vous sélectionnez **non**, l’instruction Select retourne un jeu de résultats.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** º|  
  
## <a name="returning-clause-conversion"></a>Returning, conversion de clause  
  
|Terme|Définition|  
|-|-|  
|**Conversion de la clause Returning dans l’instruction DELETE en sortie**|Oracle fournit une clause Returning pour obtenir immédiatement les valeurs supprimées. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]fournit cette fonctionnalité avec la clause OUTPUT.<br /><br />Si vous sélectionnez **Oui**, SSMA convertira les CLAUSEs renvoyées dans les instructions DELETE en clauses de sortie. Étant donné que les déclencheurs sur une table peuvent modifier des valeurs, la valeur retournée peut être différente dans la mesure [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] où elle se trouvait dans Oracle.<br /><br />Si vous sélectionnez **non**, SSMA génère une instruction SELECT avant les instructions DELETE pour récupérer les valeurs retournées.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|  
|**Conversion de la clause Returning dans l’instruction INSERT en sortie**|Oracle fournit une clause Returning pour obtenir immédiatement des valeurs insérées. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]fournit cette fonctionnalité avec la clause OUTPUT.<br /><br />Si vous sélectionnez **Oui**, SSMA convertit une clause Returning dans une instruction INSERT en sortie. Étant donné que les déclencheurs sur une table peuvent modifier des valeurs, la valeur retournée peut être différente dans la mesure [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] où elle se trouvait dans Oracle.<br /><br />Si vous sélectionnez **non**, SSMA émule la fonctionnalité Oracle en insérant, puis en sélectionnant des valeurs dans une table de référence.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|  
|**Conversion de la clause Returning dans l’instruction UPDATE en sortie**|Oracle fournit une clause Returning pour obtenir immédiatement les valeurs mises à jour. [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]fournit cette fonctionnalité avec la clause OUTPUT.<br /><br />Si vous sélectionnez **Oui**, SSMA convertira les CLAUSEs renvoyées dans les instructions Update en clauses de sortie. Étant donné que les déclencheurs sur une table peuvent modifier des valeurs, la valeur retournée peut être différente dans la mesure [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] où elle se trouvait dans Oracle.<br /><br />Si vous sélectionnez **non**, SSMA génère des instructions SELECT après les instructions Update pour récupérer les valeurs retournées.<br /><br />Lorsque vous sélectionnez un mode de conversion dans la zone **mode** , SSMA applique le paramètre suivant :<br /><br />**Mode par défaut/optimiste/mode complet :** Oui|  
  
## <a name="sequence-conversion"></a>Conversion de séquence  
  
|Terme|Définition|  
|-|-|  
|**Convertir le générateur de séquence**|Dans Oracle, vous pouvez utiliser une séquence pour générer des identificateurs uniques.<br /><br />SSMA peut convertir les séquences vers les éléments suivants.<br /><br />À l’aide de SQL Server Générateur de séquence (cette option est disponible uniquement lors de la conversion en SQL Server 2012 et SQL Server 2014).<br /><br />À l’aide du générateur de séquence SSMA.<br /><br />Utilisation de l’identité de colonne.<br /><br />L’option par défaut lors de la conversion en SQL Server 2012 ou SQL Server 2014 est d’utiliser le générateur de séquences SQL Server. Toutefois, SQL Server 2012 et SQL Server 2014 ne prennent pas en charge l’obtention de la valeur de séquence actuelle (telle que celle de la méthode CURRVAL de la séquence Oracle). Consultez le site du blog de l’équipe SSMA pour obtenir de l’aide sur la migration de la méthode CURRVAL de séquence Oracle.<br /><br />SSMA fournit également une option permettant de convertir une séquence Oracle en émulateur de séquence SSMA. Il s’agit de l’option par défaut lors de la conversion en SQL Server avant 2012<br /><br />Enfin, vous pouvez également convertir une séquence assignée à une colonne de table en SQL Server valeurs d’identité. Vous devez spécifier le mappage entre les séquences et une colonne d’identité sous l’onglet **table** Oracle.|  
|**Convertir les CURRVAL en dehors des déclencheurs**|Visible uniquement lorsque le générateur de séquence Convert a la valeur à **l’aide de l’identité de colonne**. Étant donné que les séquences Oracle sont des objets distincts des tables, de nombreuses tables qui utilisent des séquences utilisent un déclencheur pour générer et insérer une nouvelle valeur de séquence. SSMA commente ces instructions ou les marque comme des erreurs lorsque les commentaires génèrent des erreurs.<br /><br />Si vous sélectionnez **Oui**, SSMA marque toutes les références aux déclencheurs externes sur la séquence convertie CURRVAL avec un avertissement.<br /><br />Si vous sélectionnez **non**, SSMA marque toutes les références aux déclencheurs externes sur la séquence convertie CURRVAL avec une erreur.|  
  
## <a name="see-also"></a>Voir aussi  
[Référence de l’interface utilisateur &#40;OracleToSQL&#41;](../../ssma/oracle/user-interface-reference-oracletosql.md)  
  
